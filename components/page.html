<div class="strib strib-styles strib-styles-specifically">
  <div class="container-lg">
    <div class="hero">
      <div class="container-md">
        <img src="http://static.startribune.com/news/projects/all/2018-summer-camp-guide/assets/images/camp-guide-logo.jpg" alt="Star Tribune summer camp guide logo">

        <h1>2018 Minnesota Summer Camp Guide</h1>

        <p class="lead">Kids can learn how to program robots, play chess,
          speak Chinese or dance hip-hop style, among other
          enrichment options.</p>
      </div>
    </div>

    <div class="sharing-wrapper">
      <!-- sharing -->
    </div>

    {{#if camps}}
      {{#if isBrowser}}
        <div class="filters">
          <div class="row">
            <div class="col col-33">
              <div class="category-filter-wrapper">
                {{#each categoryList as c, i}}
                  <input type="checkbox" id="filter-category-{{ i }}" on:change="categoryCheck(event, c)">
                  <label for="filter-category-{{ i }}">{{ c }}</label><br>
                {{/each}}
              </div>
            </div>

            <div class="col col-33">
              <InputSlider
                min="{{ minPrice }}" max="{{ maxPrice }}"
                bind:minValue="filters.minPrice" bind:maxValue="filters.maxPrice" />
            </div>

            <div class="col col-33">
              <InputDateRange min="{{ minDate }}" max="{{ maxDate }}"
                bind:minValue="filters.minDate" bind:maxValue="filters.maxDate" />
            </div>
          </div>

          <div class="row">
            <div class="col col-33">
              <InputSlider
                min="{{ minAge }}" max="{{ maxAge }}" step="1"
                bind:minValue="filters.minAge" bind:maxValue="filters.maxAge"
                label="Age" formatUnit="{{ (i) => i }}"/>
            </div>

            <div class="col col-33">
              <InputSlider
                min="{{ minGrade }}" max="{{ maxGrade }}" step="1"
                bind:minValue="filters.minGrade" bind:maxValue="filters.maxGrade"
                label="Grade" formatUnit="{{ (i) => i === -1 ? 'PreK' : i === 0 ? 'K' : i }}"/>
            </div>

            <div class="col col-33">
              <label>Stay types</label>

              <div class="checkbox-set">
                <input type="checkbox" id="filter-type-full" bind:checked="filters.type.full">
                <label for="filter-type-full">Full day</label><br>

                <input type="checkbox" id="filter-type-extended" bind:checked="filters.type.extended">
                <label for="filter-type-extended">Extended day</label><br>

                <input type="checkbox" id="filter-type-half" bind:checked="filters.type.half">
                <label for="filter-type-half">Half day</label><br>

                <input type="checkbox" id="filter-type-overnight" bind:checked="filters.type.overnight">
                <label for="filter-type-overnight">Overnight</label><br>
              </div>
            </div>
          </div>

          <div class="row">
            <div class="col col-100">
              <div class="address-search">
                <label for="address-input">We'll use your address, city, or zip to find camps close to you</label>

                <input id="address-input" type="text"
                  placeholder="Your address, city, or zip"
                  bind:value="addressInput">

                <div class="found-address">{{ addressFound }}</div>
              </div>
            </div>
          </div>
        </div>
      {{/if}}

      <div class="camp-count">
        Showing {{ filteredCamps.length || 0 }}
        camp{{ filteredCamps.length === 1 ? '' : 's' }}.
      </div>

      <div class="camps">
        {{#each filteredCamps as c, i @id}}
          {{#if i < 50}}
            <Camp camp="{{ c }}" userLocation="{{ userLocation }}" />
          {{/if}}
        {{/each}}
      </div>

      <div class="pages">
        <em>TODO: pages</em>
      </div>
    {{/if}}
  </div>
</div>

<script>
import Camp from './camp.html';
import InputSlider from './input-slider.html';
import InputDateRange from './input-date-range.html';
import { DateTime } from 'luxon';
import { setDeep, getDeep } from 'svelte-extras';
import _ from 'lodash';
import { distance } from '../app/common.js';

export default {
  components: {
    Camp,
    InputSlider,
    InputDateRange
  },

  oncreate: function() {
    this.throttledSearchAddress = _.throttle(
      _.bind(this.searchAddress, this),
      2000
    );

    // Observe changes in address search
    this.observe('addressInput', n => {
      if (n) {
        this.throttledSearchAddress(null, n);
      }
    });

    // Make geocoder
    if (this.get('isBrowser') && window.google) {
      this.geocoder = new window.google.maps.Geocoder();
    }
  },

  methods: {
    setDeep,
    getDeep,

    categoryCheck: function(e, category) {
      if (e && e.preventDefault) {
        e.preventDefault();
      }

      let current = this.getDeep(`filters.categories.${category}`);
      this.setDeep(`filters.categories.${category}`, !current);
    },

    searchAddress: function(e, address) {
      if (e && e.preventDefault) {
        e.preventDefault();
      }

      this.set({ isGeocoding: true });
      this.geocoder.geocode({ address }, (results, status) => {
        if (status !== 'OK' || !results || !results.length) {
          console.error(`Bad response from geocoder: ${status}`);
          // TODO handle error
          return;
        }

        this.set({
          userLocation: results[0].geometry.location.toJSON(),
          addressFound: results[0].formatted_address,
          isGeocoding: false
        });
      });
    }
  },

  computed: {
    // Create filtered and sorted camps
    filteredCamps: (camps, filters, userLocation) => {
      let filtered = camps;

      if (camps && camps.length && filters) {
        // Price, min or max price within range
        filtered = filtered.filter(c => {
          return (
            (c.minPrice >= filters.minPrice &&
              c.minPrice <= filters.maxPrice) ||
            (c.maxPrice >= filters.minPrice && c.maxPrice <= filters.maxPrice)
          );
        });

        // Date filtering
        if (filters.minDate) {
          let m = DateTime.fromISO(filters.minDate);
          filtered = filtered.filter(c => {
            return c.start.ts >= m.ts || c.end.ts >= m.ts;
          });
        }
        if (filters.maxDate) {
          let m = DateTime.fromISO(filters.maxDate);
          filtered = filtered.filter(c => {
            return c.start.ts <= m.ts || c.end.ts <= m.ts;
          });
        }

        // Types.  Exclude any that are explicitly excluded
        if (filters.type) {
          const typeIn = (types, type) => {
            return !!types.find(t => {
              return t && t.type === type;
            });
          };

          filtered = filtered.filter(c => {
            let included = false;

            for (const t in filters.type) {
              included = included
                ? included
                : filters.type[t] && typeIn(c.types, t);
            }

            return included;
          });
        }

        // Age.  Only filter ones that are of type age.
        if (filters.minAge) {
          filtered = filtered.filter(c => {
            return c.who && c.who.type === 'age' && c.who.min < filters.minAge
              ? false
              : true;
          });
        }
        if (filters.maxAge) {
          filtered = filtered.filter(c => {
            return c.who && c.who.type === 'age' && c.who.max > filters.maxAge
              ? false
              : true;
          });
        }

        // Grade.  Only filter ones that are of type grade.
        if (filters.minGrade) {
          filtered = filtered.filter(c => {
            return c.who &&
              c.who.type === 'grade' &&
              c.who.min < filters.minGrade
              ? false
              : true;
          });
        }
        if (filters.maxGrade) {
          filtered = filtered.filter(c => {
            return c.who &&
              c.who.type === 'grade' &&
              c.who.max > filters.maxGrade
              ? false
              : true;
          });
        }

        // Categories
        if (filters.categories) {
          let categoryFilters = [];
          for (const c in filters.categories) {
            if (filters.categories[c]) {
              categoryFilters.push(c);
            }
          }

          if (categoryFilters.length) {
            filtered = filtered.filter(c => {
              return c.categories.find(a => {
                return ~categoryFilters.indexOf(a);
              });
            });
          }
        }
      }

      // Sort by distance
      if (userLocation && userLocation.lat) {
        filtered = filtered.sort((a, b) => {
          if (!a.location || !b.location) {
            return -9999999;
          }

          return (
            distance(
              a.location.lat,
              a.location.lng,
              userLocation.lat,
              userLocation.lng
            ) -
            distance(
              b.location.lat,
              b.location.lng,
              userLocation.lat,
              userLocation.lng
            )
          );
        });
      }

      return filtered;
    },

    // Category list
    categoryList: camps => {
      let categories = [];

      if (!camps) {
        return [];
      }

      camps.forEach(c => {
        categories = categories.concat(c.categories);
      });

      return categories.filter((v, i, a) => a.indexOf(v) === i).sort((a, b) => {
        return a - b;
      });
    },

    // Calculate min price of all camps
    minPrice: camps => {
      return camps
        ? camps.map(c => c.minPrice).reduce((memo, p) => {
            return Math.min(memo || 999999, p);
          })
        : 0;
    },

    // Calculate max price of all the camps
    maxPrice: camps => {
      return camps
        ? camps.map(c => c.maxPrice).reduce((memo, p) => {
            return Math.max(memo || 0, p);
          })
        : 1000;
    },

    // Calculate min age of all camps
    minAge: camps => {
      return camps
        ? camps
            .map(c => (c.who && c.who.type === 'age' ? c.who.min : 999999))
            .reduce((memo, p) => {
              return Math.min(memo || 999999, p);
            })
        : 0;
    },

    // Calculate max age of all the camps
    maxAge: camps => {
      return camps
        ? camps
            .map(c => (c.who && c.who.type === 'age' ? c.who.max : 0))
            .reduce((memo, p) => {
              return Math.max(memo || 0, p);
            })
        : 1000;
    },

    // Calculate min grade of all camps
    minGrade: camps => {
      return camps
        ? camps
            .map(c => (c.who && c.who.type === 'grade' ? c.who.min : 999999))
            .reduce((memo, p) => {
              return Math.min(memo || 999999, p);
            })
        : 0;
    },

    // Calculate max grade of all the camps
    maxGrade: camps => {
      return camps
        ? camps
            .map(c => (c.who && c.who.type === 'grade' ? c.who.max : 0))
            .reduce((memo, p) => {
              return Math.max(memo || 0, p);
            })
        : 1000;
    },

    // Calculate min date of all camps
    minDate: camps => {
      return camps
        ? camps.reduce((memo, p) => {
            return memo && memo.ts && p.start && memo.ts < p.start.ts
              ? memo
              : p.start;
          })
        : '1900-01-01';
    },

    // Calculate max date of all the camps
    maxDate: camps => {
      return camps
        ? camps.reduce((memo, p) => {
            return memo && memo.ts && memo.ts > p.end.ts ? memo : p.end;
          })
        : '3000-01-01';
    }
  },

  data: () => {
    return {
      isBrowser: typeof window != 'undefined',
      addressInput: '',
      addressFound: '',
      filters: {
        minPrice: 0,
        maxPrice: 99999,
        minAge: 0,
        maxAge: 999,
        minGrade: -10,
        maxGrade: 999,
        type: {
          full: true,
          half: true,
          extended: true,
          overnight: true
        },
        categories: {}
      }
    };
  }
};
</script>
