<div class="strib strib-styles strib-styles-specifically">
  <div class="container-lg">
    {{#if camps}}
      <div class="filters cf">
        <h2>Filters</h2>

        <div class="filters-column">
          <InputSlider bind:value="filterPrice"
            min="{{ minPrice }}" max="{{ maxPrice }}"
            bind:minValue="filterPriceMin" bind:maxValue="filterPriceMax" />
        </div>
      </div>

      <div class="camps">
        <h2>Camps</h2>

        {{#each filteredCamps as c @id}}
          <Camp camp="{{ c }}" />
        {{/each}}
      </div>
    {{/if}}
  </div>
</div>

<script>
import Camp from './camp.html';
import InputSlider from './input-slider.html';
import { setDeep } from 'svelte-extras';

export default {
  components: {
    Camp,
    InputSlider
  },

  methods: {
    setDeep
  },

  computed: {
    // Combine filters for convienve
    filters: (filterPriceMin, filterPriceMax) => {
      return {
        minPrice: filterPriceMin || 0,
        maxPrice: filterPriceMax || 999999
      };
    },

    // Create filtered and sorted camps
    filteredCamps: (camps, filters) => {
      let filtered = camps;

      if (camps && camps.length && filters) {
        // Type
        if (filters.type) {
          filtered = filtered.filter(c => {
            return _.find(c.types, t => t.type === filters.type);
          });
        }

        // Price, min or max price within range
        filtered = filtered.filter(c => {
          return (
            (c.minPrice >= filters.minPrice &&
              c.minPrice <= filters.maxPrice) ||
            (c.maxPrice >= filters.minPrice && c.maxPrice <= filters.maxPrice)
          );
        });
      }

      return filtered;
    },

    // Calculate min price of all camps
    minPrice: camps => {
      return camps
        ? camps.map(c => c.minPrice).reduce((memo, p) => {
            return Math.min(memo || 999999, p);
          })
        : 0;
    },

    // Calculate max price of all the camps
    maxPrice: camps => {
      return camps
        ? camps.map(c => c.maxPrice).reduce((memo, p) => {
            return Math.max(memo || 0, p);
          })
        : 1000;
    }
  },

  data: () => {
    return {};
  }
};
</script>
